/*
 * Copyright 2018 Infostellar, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

import "google/protobuf/timestamp.proto";

package stellarstation.api.v1;

option go_package = "stellarstation";

option java_multiple_files = true;
option java_outer_classname = "StellarstationProto";
option java_package = "com.stellarstation.api.v1";

// The public API service of Stellarstation, a system supporting communication between satellites
// and ground stations. This API is for use by an operator of a satellite - it is invalid to specify
// satellites that the operator does not own or plans they have not reserved.
// Only using IDs shown on the StellarStation Console or returned in API responses will ensure all
// inputs are valid.
//
// A pass is a time range where an ground station and satellite can communicate with each other, i.e.,
// the period between Acquisition of Signal (AOS) and Loss of Signal (LOS) of the ground station and
// satellite pair.
//
// A plan is a scheduled pass that will be executed to send and receive data between the ground
// station and satellite during the time range.
service StellarStationService {

  // Lists upcoming passes for a satellite. Passes that can be scheduled for the satellite with an
  // Acquisition of Signal (AOS) within 14 days from now will be returned. This method does not
  // reserve passes in any way - it is possible for a pass that is returned by this method to be
  // unschedulable when actually trying to schedule because a conflict appeared during that time.
  //
  // If the satellite is not found or the client is not authorized for it, the request will return
  // a `NOT_FOUND` error.
  rpc ListUpcomingAvailablePasses (ListUpcomingAvailablePassesRequest) returns (ListUpcomingAvailablePassesResponse);

  // Open a stream to a satellite. The returned stream is bi-directional - it can be used by the
  // client to send commands to the satellite and data received from the satellite will be returned
  // as it is made available. All telemetry received from the satellite on reserved passes from this
  // point on will be returned as soon as this method is called. If
  // `SatelliteStreamRequest.stream_id` is specified, any messages that have been buffered for the
  // stream will be returned as well.
  //
  // The stream can be left open for any amount of time and telemetry will be received as available
  // and returned. When the client is done with the stream, it should close it successfully. If the
  // stream is cancelled with an unexpected error at any point, telemetry received before the next
  // call to `OpenSatelliteStream` to resume the stream will be buffered up to 1 minute, and if no
  // call to `OpenSatelliteStream` is made with `stream_id` specified to resume the stream, it will
  // expire in 10 minutes and a call to `OpenSatelliteStream` with that `stream_id` will be closed
  // with a `ABORTED` error.
  //
  // If the satellite is not found or the client is not authorized for it, the stream will be closed
  // with a `NOT_FOUND` error.
  rpc OpenSatelliteStream (stream SatelliteStreamRequest) returns (stream SatelliteStreamResponse);

  // Reserves a pass for later execution as a plan. The pass must be specified by a
  // `reservation_token` returned in another method like `ListUpcomingAvailablePasses` and its
  // `aos_time` must be at least one hour in the future.
  //
  // If the `reservation_token` is invalid, the request will return an `INVALID_ARGUMENT` error.
  //
  // If the requested pass cannot be scheduled due to a conflict with existing plans or other
  // scheduling constraints, the request will return a `FAILED_PRECONDITION` error. This includes
  // if the pass `aos_time` is less than one hour in the future.
  //
  // Note that the reservation_token may have become unreservable since it was fetched. If that's
  // the case, the call to `ReservePass` will fail with a 'FAILED_PRECONDITION' error and
  // `ListUpcomingAvailablePasses` should be called again to get a fresh list of reservable passes.
  // The pass must be scheduled at least one hour in advance of `aos_time` or it will be rejected.
  rpc ReservePass (ReservePassRequest) returns (ReservePassResponse);
}

//----------------------------------------------------------------------------------------------
// Streaming APIs.
//----------------------------------------------------------------------------------------------

// Request for the `OpenSatelliteStream` method.
message SatelliteStreamRequest {
  // The ID of the satellite to open a stream with. The ID of a satellite can be found on the
  // StellarStation Console page for the satellite.
  string satellite_id = 1;

  // The `SatelliteStreamResponse.stream_id` from a previously opened stream to resume. If the
  // specified stream has already expired or been closed, the stream is closed with a `ABORTED`
  // error.
  string stream_id = 2;

  // A request to send on the satellite stream. Currently only command sending to the satellite is
  // supported. The request does not need to be filled on the first request to
  // `OpenSatelliteStream`.
  oneof Request {
    // A request to send commands to the satellite.
    SendSatelliteCommandsRequest send_satellite_commands_request = 3;
  }

  // The `Framing` types to accept, for satellites that have been configured for multiple framings
  // (e.g., IQ + AX25). If empty, all framings produced by the satellite will be returned.
  repeated Framing accepted_framing = 4;
}

// A request to send commands to a satellite.
//
// Next ID: 1
message SendSatelliteCommandsRequest {
  // The command frames to send to the satellite. All commands will be transmitted in sequence
  // immediately, during which time telemetry will not be received. After all commands have been
  // transmitted, telemetry receive will be immediately re-enabled. The maximum size of each command
  // is 2MB. If a command larger than 2MB is received, the stream will be closed with a
  // `RESOURCE_EXHAUSTED` error.
  repeated bytes command = 2;
}

// A type of framing of a binary payload used in satellite communicaation.
enum Framing {
  // No framing done in the API. All payloads are assumed to be pre-framed and ready for
  // transmission to the satellite or API client with no additional processing.
  BITSTREAM = 0;

  // AX.25 (Amateur X.25) framing - https://en.wikipedia.org/wiki/AX.25
  AX25 = 1;

  // No framing or demodulation done in the API. Raw IQ data is sent to the API client with no
  // additional processing.
  IQ = 2;

  // A decoded PNG image frame.
  IMAGE_PNG = 3;
}

// A response from the `OpenSatelliteStream` method.
message SatelliteStreamResponse {
  // The ID of this stream, which can be used in a subsequent call to `OpenSatelliteStream` to
  // resume this stream on interruption (e.g., if a network failure causes the connection to be
  // closed mid-stream). Telemetry received on a previously opened stream with no current listener
  // will be buffered for a maximum of 1 minute, and the stream itself will be cancelled and no more
  // buffering will occur if no client resumes the stream with `OpenSatelliteStream` within 10
  // minutes.
  string stream_id = 1;

  // A response on the stream. Currently the only type of response is telemetry received from the
  // satellite.
  oneof Response {
    // A response from a satellite containing telemetry.
    ReceiveTelemetryResponse receive_telemetry_response = 2;
  }
}

// A response from a satellite containing telemetry.
message ReceiveTelemetryResponse {
  // The telemetry received.
  Telemetry telemetry = 1;
}

// A chunk or frame of telemetry data that has been received from a satellite.
message Telemetry {
  // The framing of this telemetry data. If `RAW`, this telemetry will be an arbitrarily sized
  // chunk of the bitstream.
  Framing framing = 1;

  // The payload of this telemetry.
  bytes data = 2;

  // The actual downlink frequency, in Hz, used when receiving `data`, including adjustments for
  // doppler shift.
  uint64 downlink_frequency_hz = 3;

  // Timestamp when the first byte of `data` was received.
  google.protobuf.Timestamp time_first_byte_received = 4;

  // Timestamp when the last byte of `data` was received.
  google.protobuf.Timestamp time_last_byte_received = 5;

  // The binary header of the telemetry frame, if `framing` is not `RAW`.
  //
  // * AX25 - This is either Address + Control, or Address + Control + PID. The checksum is not
  //          returned.
  bytes frame_header = 6;
}

//----------------------------------------------------------------------------------------------
// Scheduling APIs.
//----------------------------------------------------------------------------------------------

// Request for the `ListUpcomingAvailablePasses` method.
message ListUpcomingAvailablePassesRequest {
  // The ID of the satellite to list passes for. The ID of a satellite can be found on the
  // StellarStation Console page for the satellite.
  string satellite_id = 1;
}

// Response for the `ListUpcomingAvailablePasses` method.
message ListUpcomingAvailablePassesResponse {
  // The upcoming, schedulable passes for the satellite.
  repeated Pass pass = 1;
}

// Request for the `ReservePass` method.
message ReservePassRequest {
  // The token that specifies the pass, as returned in `Pass.reservation_token`.
  string reservation_token = 1;
}

// Response for the `ReservePass` method.
message ReservePassResponse {
  // The reserved plan.
  Plan plan = 1;
}

// A pass during which a satellite can be communicated with from a given ground station.
message Pass {
  // A unique token for this pass that can be used for scheduling it.
  string reservation_token = 1;

  // The time of Acquisition of Signal (AOS) between the ground station and satellite in this pass.
  google.protobuf.Timestamp aos_time = 2;

  // The time of Loss of Signal (LOS) between the ground station and satellite in this pass.
  google.protobuf.Timestamp los_time = 3;

  // The latitude, in degrees, of the ground station's location.
  double ground_station_latitude = 4;

  // The longitude, in degrees, of the ground station's location.
  double ground_station_longitude = 5;

  // The ISO 3166-1 alpha-2 2-letter country code for the ground station's location.
  // See https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
  string ground_station_country_code = 6;

  // The max elevation during the pass, in degrees.
  double max_elevation_degrees = 7;

  // The time of the max elevation during the pass.
  google.protobuf.Timestamp max_elevation_time = 8;

  // The center frequency, in Hz, for downlinking in this pass. 0 if downlink is not available in
  // this pass.
  uint64 downlink_center_frequency_hz = 9;

  // The center frequency, in Hz, for uplinking in this pass. 0 if uplink is not available in
  // this pass.
  uint64 uplink_center_frequency_hz = 10;
}

// A plan, specifying a time range within which a satellite will be communicated with.
message Plan {
  // The unique ID of the plan.
  string id = 1;

  // The id of the satellite to be tracked in the plan.
  string satellite_id = 2;

  // A description of the status of a plan.
  enum Status {
    // The plan is reserved for execution in the future at `aos_time`.
    RESERVED = 0;

    // The plan is currently executing and will end in the future at `los_time`.
    EXECUTING = 1;

    // The plan already finished executing successfully.
    SUCCEEDED = 2;

    // The plan failed to execute correctly.
    FAILED = 3;

    // The plan was canceled. This can be explicitly by calling `CancelPlan` or implicit due to
    // cancellation by the ground station in the plan (i.e., due to bad weather).
    CANCELED = 4;
  }
  // The status of this plan.
  Status status = 3;

  // The time of Acquisition of Signal (AOS) between the ground station and satellite in this plan.
  google.protobuf.Timestamp aos_time = 4;

  // The time of Loss of Signal (LOS) between the ground station and satellite in this plan.
  google.protobuf.Timestamp los_time = 5;

  // The latitude, in degrees, of the ground station's location.
  double ground_station_latitude = 6;

  // The longitude, in degrees, of the ground station's location.
  double ground_station_longitude = 7;

  // The ISO 3166-1 alpha-2 2-letter country code for the ground station's location.
  // See https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
  string ground_station_country_code = 8;

  // The max elevation during the plan, in degrees.
  double max_elevation_degrees = 9;

  // The time of the max elevation during the plan.
  google.protobuf.Timestamp max_elevation_time = 10;

  // The center frequency, in Hz, for downlinking in this plan. 0 if downlink is not available in
  // this plan.
  uint64 downlink_center_frequency_hz = 11;

  // The center frequency, in Hz, for uplinking in this plan. 0 if uplink is not available in
  // this plan.
  uint64 uplink_center_frequency_hz = 12;
}
